(()=>{"use strict";var __webpack_modules__={390:()=>{eval('\n;// CONCATENATED MODULE: ./src/services/dataManager.js\nlet data;\n\nasync function fetchPhotographers() {\n\tconst res = await fetch("./data/FishEyeData.json");\n\tdata = await res.json();\n\treturn data.photographers;\n}\n\n\n\nasync function fetchMedia() {\n\tconst res = await fetch("./data/FishEyeData.json");\n\tdata = await res.json();\n\treturn data.media;\n}\n\n\n\n;// CONCATENATED MODULE: ./src/components/btContact/btContact.js\n// export default function BtContact() {\n// \tconst btContacts = document.querySelectorAll(".btContact[type=button]");\n// \tconst bground = document.querySelector(".bground");\n\n// \t/**\n// \t * Au clic sur un des boutons "Contactez moi" => Ouverture de la form-modal\n// \t */\n// \tbtContacts.forEach((btContact) =>\n// \t\tbtContact.addEventListener("click", function () {\n// \t\t\tbground.setAttribute("visible", "true");\n// \t\t})\n// \t);\n// }\n\nclass BtContact {\n\tconstructor(domtarget, props) {\n\t\tthis.DOM = domtarget;\n\t\tthis.className = props.className;\n\t\tthis.type = props.type;\n\t\tthis.text = props.text;\n\t\tthis.render();\n\t}\n\trender() {\n\t\tthis.DOM.innerHTML += /* html */ `\n\t\t<button class="${this.className}" type="${this.type}">\n    \t${this.text}\n\t\t</button>\n\t\t\n\t\t`;\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/tags/tags.js\nclass Tags {\n\tconstructor(domTarget, tag, className, className2) {\n\t\tthis.DOM = domTarget;\n\t\tthis.tag = tag;\n\t\tthis.className = [className];\n\t\tif (className2) {\n\t\t\tthis.className.push(className2);\n\t\t}\n\t\tthis.render();\n\t}\n\trender() {\n\t\tconst button = document.createElement("button");\n\t\tthis.className.forEach((newClass) => {\n\t\t\tbutton.classList.add(newClass);\n\t\t});\n\t\tthis.DOM.appendChild(button);\n\t\tbutton.innerHTML += /* html */ `#${this.tag}`;\n\t\tthis.addDisabled(button);\n\t}\n\n\taddDisabled(button) {\n\t\tif (this.className.length === 1) {\n\t\t\tbutton.disabled = true;\n\t\t}\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/header/header.js\n\n\nclass Header {\n\t/**\n\t * [constructor description]\n\t *\n\t * @param   {HTMLElement}  domTarget   [domTarget description]\n\t * @param\t\t{array} tagsChecked\n\t * @param   {String}  className   [className description]\n\t * @param   {String}  [className2]  [className2 description]\n\t */\n\tconstructor(domTarget, tagsChecked, className, className2) {\n\t\tthis.DOM = domTarget;\n\t\tthis.tagsChecked = tagsChecked;\n\t\tthis.className = [className];\n\t\tif (className2) this.className.push(className2);\n\t\tthis.tagsValueArray = [\n\t\t\t"portrait",\n\t\t\t"art",\n\t\t\t"fashion",\n\t\t\t"architecture",\n\t\t\t"travel",\n\t\t\t"sports",\n\t\t\t"animals",\n\t\t\t"events",\n\t\t];\n\t\tthis.render();\n\t}\n\trender() {\n\t\tthis.DOM.innerHTML = "";\n\t\tconst header = document.createElement("header");\n\t\tthis.DOM.appendChild(header);\n\t\tthis.className.forEach((newClass) => {\n\t\t\theader.classList.add(newClass);\n\t\t});\n\t\theader.innerHTML = /* html */ `\n\t\t\t<button class="logo" title="logo" alt="Fisheye Home Page" >\n\t\t\t\t<img src="./img/logo/logo.svg" alt="" onclick="goHome()">\n\t\t\t</button>\n\t\t\t<h1 class="lobbyH1">Nos photographes</h1>\n\t\t\t `;\n\t\tif (this.className.length === 1) {\n\t\t\tconst nav = document.createElement("nav");\n\t\t\tthis.tagsValueArray.forEach((tagValue) => {\n\t\t\t\tnew Tags(nav, tagValue, "tags", "tags-link");\n\t\t\t});\n\t\t\theader.appendChild(nav);\n\t\t\tconst tags = document.querySelectorAll(".tags-link");\n\t\t\tthis.tagsChecked.forEach((tagChecked) => {\n\t\t\t\ttags.forEach((tag) => {\n\t\t\t\t\tif (tag.innerHTML == tagChecked) {\n\t\t\t\t\t\ttag.setAttribute("isChecked", "true");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/photographer-card/photographer-card.js\n\n/**\n * Carte du photographe dans le lobby\n */\nclass PhotographerCard {\n\tconstructor(domTarget, props) {\n\t\tthis.DOM = domTarget;\n\t\tthis.articleClassName = props.articleClassName;\n\t\tthis.btClassName = props.btClassName;\n\t\tthis.imgLink = "./img/PhotographersIDPhotos/" + props.portrait;\n\t\tthis.name = props.name;\n\t\tthis.location = props.city + ", " + props.country;\n\t\tthis.tagline = props.tagline;\n\t\tthis.price = props.price + "€/jour";\n\t\tthis.tags = props.tags;\n\t\tthis.id = props.id;\n\t\tthis.render();\n\t}\n\trender() {\n\t\tconst article = document.createElement("article");\n\t\tarticle.className = this.articleClassName;\n\t\t// article.id = this.id;\n\t\tthis.DOM.appendChild(article);\n\t\tarticle.innerHTML += /* html */ `\n      <button class=${this.btClassName} id=${this.id} > \n        <div class="photographer-card-link-imgContainer">\n          <img src=${this.imgLink}  alt="" cover width="208px" height="208px"/>\n        </div>\n        <h2>\n          ${this.name}\n        </h2>\n      </button>\n\t\t\t<p class="location">\n        ${this.location}\n      </p>\n      <p class="tagline tagline_photographerPages">\n        ${this.tagline}\n      </p>\n      <p class="price">\n        ${this.price}\n      </p>\n    `;\n\t\tconst nav = document.createElement("nav");\n\t\tnav.title = this.name + "Tags";\n\t\tthis.tags.forEach((/** @type {any} */ tag) => {\n\t\t\tnew Tags(nav, tag, "tags");\n\t\t});\n\t\tarticle.appendChild(nav);\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/photographer-card-big/photographer.card.big.js\n\n\n\n\n/**\n * Carte du photographe dans sa page perso\n */\nclass PhotographerCardBig extends PhotographerCard {\n\tconstructor(domTarget, props) {\n\t\tsuper(domTarget, props);\n\t\t// this.DOM = domTarget;\n\t\t// this.articleClassName = props.articleClassName;\n\t\t// this.btClassName = props.btClassName;\n\t\t// this.imgLink = "./img/PhotographersIDPhotos/" + props.portrait;\n\t\t// this.nom = props.name;\n\t\t// this.location = props.city + ", " + props.country;\n\t\t// this.tagline = props.tagline;\n\t\t// this.price = props.price + "€/jour";\n\t\t// this.tags = props.tags;\n\t\t// this.id = props.id;\n\n\t\t// this.render();\n\t}\n\trender() {\n\t\tconst article = document.createElement("article");\n\t\tarticle.className = this.articleClassName;\n\t\tthis.DOM.appendChild(article);\n\t\tarticle.innerHTML = /* html */ `\n\t\t\t\t\t\t<div class="photographer-card-link-imgContainer photographer-card-big-imgContainer">\n\t\t\t\t\t\t\t<img src="${this.imgLink}"  alt="" cover />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<h2>\n\t\t\t\t\t\t\t${this.name}\n\t\t\t\t\t\t</h2>\n\t\t\t\t\t\t<p class="location">\n\t\t\t\t\t\t\t${this.location}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p class="tagline">\n\t\t\t\t\t\t\t${this.tagline}\n\t\t\t\t\t\t</p>\n   `;\n\t\tconst nav = document.createElement("nav");\n\t\tthis.tags.forEach((tag) => {\n\t\t\tnew Tags(nav, tag, "tags", "tags-link");\n\t\t});\n\t\tarticle.appendChild(nav);\n\t\tthis.insertBtContactDesktop(article);\n\t\tthis.insertBtContactMobile(article);\n\t}\n\t/**\n\t * Insertion du bouton contact version desktop\n\t *\n\t * @param   {HTMLElement}  article  Description du photographe\n\t *\n\t * @return  {void}       \t Insertion du bouton contact version desktop\n\t */\n\tinsertBtContactDesktop(article) {\n\t\tnew BtContact(article, {\n\t\t\tclassName: "btContact btContact-desktop",\n\t\t\ttype: "button",\n\t\t\ttext: "Contactez moi",\n\t\t});\n\t}\n\t/**\n\t * Insertion du bouton contact version mobile\n\t *\n\t * @param   {HTMLElement}  article  Description du photographe\n\t *\n\t * @return  {void}       \t Insertion du bouton contact version mobile\n\t */\n\tinsertBtContactMobile(article) {\n\t\tnew BtContact(article, {\n\t\t\tclassName: "btContact btContact-mobile",\n\t\t\ttype: "button",\n\t\t\ttext: "Contactez moi",\n\t\t});\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/widget/widget.js\nclass Widget {\n\tconstructor(domTarget) {\n\t\tthis.DOM = domTarget;\n\t\tthis.render();\n\t}\n\trender() {\n\t\tthis.DOM.innerHTML += /* html */ `\n\t\t<div class="no-widget" id="widget">\n\t\t<label for="select" onclick=toggleOptList(select)>Trier par</label>\n\t\t<form>\n\t\t\t<select name="Popularité">\n\t\t\t\t<option>Popularité</option>\n\t\t\t\t<option>Date</option>\n\t\t\t\t<option>Titre</option>\n\t\t\t</select>\n\t\t\t<div class="select" tabindex="0" id="select" role="listbox">\n\t\t\t\t\x3c!-- Ce containeur sera utilisé pour afficher la valeur courante du widget --\x3e\n\t\t\t\t<span class="value">Popularité</span>\n\t\t\t\t\x3c!-- Ce conteneur contiendra toutes les options disponibles pour le widget.\n\tComme c\'est une liste, il y sens à utiliser l\'élément ul. --\x3e\n\t\t\t\t<ul class="optList hidden" role="presentation">\n\t\t\t\t\t\x3c!-- Chaque option ne contient que la valeur à afficher, Nous verrons plus loin\n\tcomment gérer la valeur réelle qui sera envoyée avec les données du formulaire --\x3e\n\t\t\t\t\t<li class="option" role="option">Popularité</li>\n\t\t\t\t\t<li class="option" role="option">Date</li>\n\t\t\t\t\t<li class="option" role="option">Titre</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</form>\n\t</div>\n\t\t\n\t\t\n\t\t`;\n\t\tconst widget = document.getElementById("widget");\n\t\twidget.classList.remove("no-widget");\n\t\twidget.classList.add("widget");\n\n\t\t// Cette fonction est utilisée chaque fois que nous voulons désactiver un\n\t\t// widget personnalisé. Elle prend un paramètre\n\t\t// select : le nœud DOM avec la classe select à désactiver\n\t\tfunction deactivateSelect(select) {\n\t\t\t// Si le widget n\'est pas actif, il n\'y a rien à faire\n\t\t\tif (!select.classList.contains("active")) return;\n\t\t\t// Nous devons obtenir la liste des options pour le widget personnalisé\n\t\t\tlet optList = select.querySelector(".optList");\n\t\t\t// Nous cachons la liste des options\n\t\t\toptList.classList.add("hidden");\n\t\t\t// et nous désactivons le widget personnalisé lui-même\n\t\t\tselect.classList.remove("active");\n\t\t}\n\n\t\t// Cette fonction sera utilisée chaque fois que l\'utilisateur veut (des)activer le widget\n\t\t// Elle prend deux paramètres :\n\t\t// select : le nœud DOM de la classe `select` à activer\n\t\t// selectList : la liste de tous les nœuds DOM de la classe `select`\n\t\tfunction activeSelect(select, selectList) {\n\t\t\t// Si le widget est déjà actif il n\'y a rien à faire\n\t\t\tif (select.classList.contains("active")) return;\n\t\t\t// Nous devons désactiver tous les widgets personnalisés\n\t\t\t// comme la fonction deactivateSelect remplit toutes les fonctionnalités de la\n\t\t\t// fonction de rappel forEach, nous l\'utilisons directement sans utiliser\n\t\t\t// une fonction anonyme intermédiaire.\n\t\t\tselectList.forEach(deactivateSelect);\n\t\t\t// Et nous activons l\'état du widget donné\n\t\t\t// select.classList.add("active");\n\t\t}\n\n\t\t// Cette fonction sera utilisée chaque fois que l\'utilisateur veut enrouler/dérouler la\n\t\t// liste des options\n\t\t// Elle prend un paramètre :\n\t\t// select : le nœud DOM de la liste à basculer\n\t\tfunction toggleOptList(select) {\n\t\t\t// La liste est prise à partir du widget\n\t\t\tlet optList = select.querySelector(".optList");\n\t\t\t// Nous changeons la classe de la liste pour l\'enrouler/dérouler\n\t\t\toptList.classList.toggle("hidden");\n\t\t\tselect.classList.toggle("active");\n\t\t}\n\n\t\t// Cett fonction sera utilisée chaque fois qu\'il faut mettre en surbrillance\n\t\t// une option.  Elle prend deux paramètres :\n\t\t// select : le nœud DOM de la classe `select`\n\t\t//          contenant l\'option à mettre en surbrillance\n\t\t// option : le nœud DOM de la classe `option` à mettre en surbrillance\n\t\tfunction highlightOption(select, option) {\n\t\t\t// Obtenir la liste de toutes les options disponibles pour l\'élémént sélectionné\n\t\t\tlet optionList = select.querySelectorAll(".option");\n\t\t\t// Supprimer la surbrillance pour toutes les options\n\t\t\toptionList.forEach(function (other) {\n\t\t\t\tother.classList.remove("highlight");\n\t\t\t});\n\t\t\t// Mettre en surbrillance l\'option correcte\n\t\t\toption.classList.add("highlight");\n\t\t}\n\n\t\t// Nous lions le widget aux événements dès le chargement du document\n\t\tlet selectList = document.querySelectorAll(".select");\n\t\t// Chaque widget personnalisé doit être initialisé\n\t\tselectList.forEach(function (select) {\n\t\t\t// de même que tous les éléments `option`\n\t\t\tlet optionList = select.querySelectorAll(".option");\n\t\t\t// Chaque fois que l\'utilisateur passe le pointeur de souris\n\t\t\t// sur une option, nous mettons en surbrillance la dite option\n\t\t\toptionList.forEach(function (option) {\n\t\t\t\toption.addEventListener("mouseover", function () {\n\t\t\t\t\t// Note : les variables `select` et `option` sont des "closures"\n\t\t\t\t\t// disponibles dans la portée de notre appel de fonction.\n\t\t\t\t\thighlightOption(select, option);\n\t\t\t\t});\n\t\t\t});\n\t\t\t// Chaque fois que l\'utilisateur clique sur un élément personnalisé\n\t\t\tselect.addEventListener("click", function () {\n\t\t\t\t// Note : la variable `select` est une "closure"\n\t\t\t\t// available dans la portée de notre appel de fonction.\n\t\t\t\t// Nous basculons la visibilité de la liste des options\n\t\t\t\ttoggleOptList(select);\n\t\t\t});\n\t\t\t// Dans le cas où le widget obtient le focus\n\t\t\t// Le widget obtient le focus chaque fois que l\'utilisateur clique dessus\n\t\t\t// ou presse la touche Tab pour avoir accès au widget\n\t\t\tselect.addEventListener("focus", function () {\n\t\t\t\t// Note : les variable `select` et `selectList` sont des "closures"\n\t\t\t\t// disponibles dans la portée de notre appel de fonction.\n\t\t\t\t// Nous activons le widget\n\t\t\t\tactiveSelect(select, selectList);\n\t\t\t});\n\t\t\t// Dans le cas où le widget perd le focus\n\t\t\tselect.addEventListener("blur", function () {\n\t\t\t\t// Note : la variable `select` est une "closure"\n\t\t\t\t// disponible dans la portée de notre appel de fonction.\n\t\t\t\t// Nous désactivons le widget\n\t\t\t\tdeactivateSelect(select);\n\t\t\t});\n\t\t});\n\t\t// Cette fonction met à jour la valeur affichée et la synchronise avec celle\n\t\t// du widget natif. Elle prend deux paramètres :\n\t\t// select : le nœud DOM de la classe `select` contenant la valuer à mettre à jour\n\t\t// index  : l\'index de la valeur choisie\n\t\tfunction updateValue(select, index) {\n\t\t\t// Nous devons obtenir le widget natif correspondant au widget personnalisé\n\t\t\t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n\t\t\tlet nativeWidget = select.previousElementSibling;\n\t\t\t// Nou devons aussi obtenir la valeur de remplacement du widget personnalisé\n\t\t\tlet value = select.querySelector(".value");\n\t\t\t// Et nous avons besoin de toute la liste des options\n\t\t\tlet optionList = select.querySelectorAll(".option");\n\t\t\t// Nous nous assurons qu\'aucune option n\'est sélectionnée\n\t\t\toptionList.forEach(function (other) {\n\t\t\t\tother.setAttribute("aria-selected", "false");\n\t\t\t});\n\t\t\t// Nous nous assurons que l\'option choisie est sélectionnée\n\t\t\toptionList[index].setAttribute("aria-selected", "true");\n\t\t\t// Nous définissons l\'index choisi à l\'index du choix\n\t\t\tnativeWidget.selectedIndex = index;\n\t\t\t// Nous mettons à jour la valeur de remplacement en accord\n\t\t\tvalue.innerHTML = optionList[index].innerHTML;\n\t\t\t// Et nous mettons en surbrillance l\'option correspondante du widget personnalisé\n\t\t\thighlightOption(select, optionList[index]);\n\t\t}\n\n\t\t// Cette fonction renvoie l\'index courant dans le widget natif\n\t\t// Elle prend un paramètre :\n\t\t// select : le nœud DOM avec la classe `select` relative au widget natif\n\t\tfunction getIndex(select) {\n\t\t\t// Nous avons besoin d\'avoir accès au widget natif pour le widget personnalisé\n\t\t\t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n\n\t\t\tlet nativeWidget = select.previousElementSibling;\n\t\t\treturn nativeWidget.selectedIndex;\n\t\t}\n\n\t\t// Nous lions le widget aux événements dès le chargement du document\n\n\t\t// let selectList = document.querySelectorAll(".select");\n\t\t// Chaque widget personnalisé doit être initialisé\n\t\tselectList.forEach(function (select) {\n\t\t\tlet optionList = select.querySelectorAll(".option"),\n\t\t\t\tselectedIndex = getIndex(select);\n\t\t\t// Nous rendons le widget personnalisé capable d\'avoir le focus\n\t\t\tselect.tabIndex = 0;\n\t\t\t// Nous faisons en sorte que le widget natif ne puisse plus avoir le focus\n\t\t\tselect.previousElementSibling.tabIndex = -1;\n\t\t\t// Nous nous assurons que la valeur sélectionnée par défaut est bien affichée\n\t\t\tupdateValue(select, selectedIndex);\n\t\t\t// Chaque fois que l\'utilisateur clique sur une option, nous mettons à\n\t\t\t// jour la valeur en accord\n\t\t\toptionList.forEach(function (option, index) {\n\t\t\t\toption.addEventListener("click", function () {\n\t\t\t\t\tupdateValue(select, index);\n\t\t\t\t});\n\t\t\t});\n\t\t\t// Chaque fois que l\'utilisateur utilise le clavier sur un widget\n\t\t\t// avec focus, les valeurs sont mises à jour en accord\n\t\t\tselect.addEventListener("keyup", function (e) {\n\t\t\t\tlet length = optionList.length,\n\t\t\t\t\tindex = getIndex(select);\n\t\t\t\t// Quand l\'utilisateur presse ⇓, nous allons à l\'option suivante\n\t\t\t\tif (e.keyCode === 40 && index < length - 1) {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\t// Quand l\'utilisateur presse ⇑, nous sautons à l\'option suivante\n\t\t\t\tif (e.keyCode === 38 && index > 0) {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\t// Quand l\'utilisateur presse enter, nous mettons à jour la valeur en accord\n\t\t\t\tif (e.keyCode === 13) {\n\t\t\t\t\tlet optList = select.querySelector(".optList");\n\t\t\t\t\t// Nous changeons la classe de la liste pour l\'enrouler/dérouler\n\t\t\t\t\toptList.classList.toggle("hidden");\n\t\t\t\t\tselect.classList.toggle("active");\n\t\t\t\t}\n\t\t\t\tupdateValue(select, index);\n\t\t\t});\n\t\t});\n\t\tconst label = document.querySelector("label");\n\t\tconst select = document.querySelector(".select");\n\t\tlabel.addEventListener("click", () => {\n\t\t\ttoggleOptList(select);\n\t\t});\n\t}\n}\n\n// const widget = document.getElementById("widget");\n\n// window.addEventListener("load", function () {\n// \twidget.classList.remove("no-widget");\n// \twidget.classList.add("widget");\n// });\n\n// // Cette fonction est utilisée chaque fois que nous voulons désactiver un\n// // widget personnalisé. Elle prend un paramètre\n// // select : le nœud DOM avec la classe select à désactiver\n// function deactivateSelect(select) {\n// \t// Si le widget n\'est pas actif, il n\'y a rien à faire\n// \tif (!select.classList.contains("active")) return;\n// \t// Nous devons obtenir la liste des options pour le widget personnalisé\n// \tlet optList = select.querySelector(".optList");\n// \t// Nous cachons la liste des options\n// \toptList.classList.add("hidden");\n// \t// et nous désactivons le widget personnalisé lui-même\n// \tselect.classList.remove("active");\n// }\n\n// // Cette fonction sera utilisée chaque fois que l\'utilisateur veut (des)activer le widget\n// // Elle prend deux paramètres :\n// // select : le nœud DOM de la classe `select` à activer\n// // selectList : la liste de tous les nœuds DOM de la classe `select`\n// function activeSelect(select, selectList) {\n// \t// Si le widget est déjà actif il n\'y a rien à faire\n// \tif (select.classList.contains("active")) return;\n// \t// Nous devons désactiver tous les widgets personnalisés\n// \t// comme la fonction deactivateSelect remplit toutes les fonctionnalités de la\n// \t// fonction de rappel forEach, nous l\'utilisons directement sans utiliser\n// \t// une fonction anonyme intermédiaire.\n// \tselectList.forEach(deactivateSelect);\n// \t// Et nous activons l\'état du widget donné\n// \t// select.classList.add("active");\n// }\n\n// // Cette fonction sera utilisée chaque fois que l\'utilisateur veut enrouler/dérouler la\n// // liste des options\n// // Elle prend un paramètre :\n// // select : le nœud DOM de la liste à basculer\n// function toggleOptList(select) {\n// \t// La liste est prise à partir du widget\n// \tlet optList = select.querySelector(".optList");\n// \t// Nous changeons la classe de la liste pour l\'enrouler/dérouler\n// \toptList.classList.toggle("hidden");\n// \tselect.classList.toggle("active");\n// }\n\n// // Cett fonction sera utilisée chaque fois qu\'il faut mettre en surbrillance\n// // une option.  Elle prend deux paramètres :\n// // select : le nœud DOM de la classe `select`\n// //          contenant l\'option à mettre en surbrillance\n// // option : le nœud DOM de la classe `option` à mettre en surbrillance\n// function highlightOption(select, option) {\n// \t// Obtenir la liste de toutes les options disponibles pour l\'élémént sélectionné\n// \tlet optionList = select.querySelectorAll(".option");\n// \t// Supprimer la surbrillance pour toutes les options\n// \toptionList.forEach(function (other) {\n// \t\tother.classList.remove("highlight");\n// \t});\n// \t// Mettre en surbrillance l\'option correcte\n// \toption.classList.add("highlight");\n// }\n\n// // Nous lions le widget aux événements dès le chargement du document\n// window.addEventListener("load", function () {\n// \tlet selectList = document.querySelectorAll(".select");\n// \t// Chaque widget personnalisé doit être initialisé\n// \tselectList.forEach(function (select) {\n// \t\t// de même que tous les éléments `option`\n// \t\tlet optionList = select.querySelectorAll(".option");\n// \t\t// Chaque fois que l\'utilisateur passe le pointeur de souris\n// \t\t// sur une option, nous mettons en surbrillance la dite option\n// \t\toptionList.forEach(function (option) {\n// \t\t\toption.addEventListener("mouseover", function () {\n// \t\t\t\t// Note : les variables `select` et `option` sont des "closures"\n// \t\t\t\t// disponibles dans la portée de notre appel de fonction.\n// \t\t\t\thighlightOption(select, option);\n// \t\t\t});\n// \t\t});\n// \t\t// Chaque fois que l\'utilisateur clique sur un élément personnalisé\n// \t\tselect.addEventListener("click", function () {\n// \t\t\t// Note : la variable `select` est une "closure"\n// \t\t\t// available dans la portée de notre appel de fonction.\n// \t\t\t// Nous basculons la visibilité de la liste des options\n// \t\t\ttoggleOptList(select);\n// \t\t});\n// \t\t// Dans le cas où le widget obtient le focus\n// \t\t// Le widget obtient le focus chaque fois que l\'utilisateur clique dessus\n// \t\t// ou presse la touche Tab pour avoir accès au widget\n// \t\tselect.addEventListener("focus", function () {\n// \t\t\t// Note : les variable `select` et `selectList` sont des "closures"\n// \t\t\t// disponibles dans la portée de notre appel de fonction.\n// \t\t\t// Nous activons le widget\n// \t\t\tactiveSelect(select, selectList);\n// \t\t});\n// \t\t// Dans le cas où le widget perd le focus\n// \t\tselect.addEventListener("blur", function () {\n// \t\t\t// Note : la variable `select` est une "closure"\n// \t\t\t// disponible dans la portée de notre appel de fonction.\n// \t\t\t// Nous désactivons le widget\n// \t\t\tdeactivateSelect(select);\n// \t\t});\n// \t});\n// });\n// // Cette fonction met à jour la valeur affichée et la synchronise avec celle\n// // du widget natif. Elle prend deux paramètres :\n// // select : le nœud DOM de la classe `select` contenant la valuer à mettre à jour\n// // index  : l\'index de la valeur choisie\n// function updateValue(select, index) {\n// \t// Nous devons obtenir le widget natif correspondant au widget personnalisé\n// \t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n// \tlet nativeWidget = select.previousElementSibling;\n// \t// Nou devons aussi obtenir la valeur de remplacement du widget personnalisé\n// \tlet value = select.querySelector(".value");\n// \t// Et nous avons besoin de toute la liste des options\n// \tlet optionList = select.querySelectorAll(".option");\n// \t// Nous nous assurons qu\'aucune option n\'est sélectionnée\n// \toptionList.forEach(function (other) {\n// \t\tother.setAttribute("aria-selected", "false");\n// \t});\n// \t// Nous nous assurons que l\'option choisie est sélectionnée\n// \toptionList[index].setAttribute("aria-selected", "true");\n// \t// Nous définissons l\'index choisi à l\'index du choix\n// \tnativeWidget.selectedIndex = index;\n// \t// Nous mettons à jour la valeur de remplacement en accord\n// \tvalue.innerHTML = optionList[index].innerHTML;\n// \t// Et nous mettons en surbrillance l\'option correspondante du widget personnalisé\n// \thighlightOption(select, optionList[index]);\n// }\n\n// // Cette fonction renvoie l\'index courant dans le widget natif\n// // Elle prend un paramètre :\n// // select : le nœud DOM avec la classe `select` relative au widget natif\n// function getIndex(select) {\n// \t// Nous avons besoin d\'avoir accès au widget natif pour le widget personnalisé\n// \t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n\n// \tlet nativeWidget = select.previousElementSibling;\n// \treturn nativeWidget.selectedIndex;\n// }\n\n// // Nous lions le widget aux événements dès le chargement du document\n// window.addEventListener("load", function () {\n// \tlet selectList = document.querySelectorAll(".select");\n// \t// Chaque widget personnalisé doit être initialisé\n// \tselectList.forEach(function (select) {\n// \t\tlet optionList = select.querySelectorAll(".option"),\n// \t\t\tselectedIndex = getIndex(select);\n// \t\t// Nous rendons le widget personnalisé capable d\'avoir le focus\n// \t\tselect.tabIndex = 0;\n// \t\t// Nous faisons en sorte que le widget natif ne puisse plus avoir le focus\n// \t\tselect.previousElementSibling.tabIndex = -1;\n// \t\t// Nous nous assurons que la valeur sélectionnée par défaut est bien affichée\n// \t\tupdateValue(select, selectedIndex);\n// \t\t// Chaque fois que l\'utilisateur clique sur une option, nous mettons à\n// \t\t// jour la valeur en accord\n// \t\toptionList.forEach(function (option, index) {\n// \t\t\toption.addEventListener("click", function () {\n// \t\t\t\tupdateValue(select, index);\n// \t\t\t});\n// \t\t});\n// \t\t// Chaque fois que l\'utilisateur utilise le clavier sur un widget\n// \t\t// avec focus, les valeurs sont mises à jour en accord\n// \t\tselect.addEventListener("keyup", function (e) {\n// \t\t\tlet length = optionList.length,\n// \t\t\t\tindex = getIndex(select);\n// \t\t\t// Quand l\'utilisateur presse ⇓, nous allons à l\'option suivante\n// \t\t\tif (e.keyCode === 40 && index < length - 1) {\n// \t\t\t\tindex++;\n// \t\t\t}\n// \t\t\t// Quand l\'utilisateur presse ⇑, nous sautons à l\'option suivante\n// \t\t\tif (e.keyCode === 38 && index > 0) {\n// \t\t\t\tindex--;\n// \t\t\t}\n// \t\t\t// Quand l\'utilisateur presse enter, nous mettons à jour la valeur en accord\n// \t\t\tif (e.keyCode === 13) {\n// \t\t\t\tlet optList = select.querySelector(".optList");\n// \t\t\t\t// Nous changeons la classe de la liste pour l\'enrouler/dérouler\n// \t\t\t\toptList.classList.toggle("hidden");\n// \t\t\t\tselect.classList.toggle("active");\n// \t\t\t}\n// \t\t\tupdateValue(select, index);\n// \t\t});\n// \t});\n// });\n\n;// CONCATENATED MODULE: ./src/components/mediaCard/mediaCard.js\nclass MediaCard {\n\tconstructor(domTarget, props) {\n\t\tthis.DOM = domTarget;\n\t\tthis.imgLink = props.imgLink;\n\t\tthis.videoLink = props.videoLink;\n\t\tthis.imgTitle = props.imgTitle;\n\t\tthis.like = props.like;\n\t\tthis.render();\n\t}\n\trender() {\n\t\tconst article = document.createElement("article");\n\t\tarticle.classList.add("mediaCard");\n\t\tthis.DOM.appendChild(article);\n\t\tconst button = document.createElement("button");\n\t\tbutton.classList.add("imgContainer");\n\t\tarticle.appendChild(button);\n\t\tthis.displayImgOrVideo(button);\n\t\tconst infoContainer = document.createElement("div");\n\t\tinfoContainer.classList.add("infoContainer");\n\t\tarticle.appendChild(infoContainer);\n\t\tconst imgTitle = document.createElement("p");\n\t\timgTitle.classList.add("imgTitle");\n\t\timgTitle.textContent = this.imgTitle;\n\t\tinfoContainer.appendChild(imgTitle);\n\t\tconst like = document.createElement("button");\n\t\tlike.classList.add("like");\n\t\tlike.textContent = this.like;\n\t\tinfoContainer.appendChild(like);\n\t\tthis.incrementLike(like);\n\t}\n\n\tincrementLike(like) {\n\t\tlike.addEventListener("click", () => {\n\t\t\tthis.like++;\n\t\t\tlike.textContent = this.like;\n\t\t});\n\t}\n\n\tdisplayImgOrVideo(button) {\n\t\tif (this.imgLink.indexOf(".jpg") !== -1) {\n\t\t\tconst img = document.createElement("img");\n\t\t\timg.src = this.imgLink;\n\t\t\timg.alt = "";\n\t\t\tbutton.appendChild(img);\n\t\t} else {\n\t\t\tconst video = document.createElement("video");\n\t\t\t// video.controls = true;\n\t\t\tbutton.appendChild(video);\n\t\t\tconst source = document.createElement("source");\n\t\t\tsource.src = this.videoLink;\n\t\t\tsource.type = "video/mp4";\n\t\t\tvideo.appendChild(source);\n\t\t}\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/components/mediaCardsSection/mediaCardsSection.js\n\n\nclass MediaCardsSection {\n\tconstructor(domTarget, props) {\n\t\tthis.DOM = domTarget;\n\t\tthis.medias = props.medias;\n\t\tthis.id = props.id;\n\t\tthis.render();\n\t}\n\trender() {\n\t\tconst section = document.createElement("section");\n\t\tsection.id = "mediaCardsSection";\n\t\tthis.DOM.appendChild(section);\n\t\tconsole.log(this.id);\n\t\tconsole.log(this.medias);\n\t\tthis.displayMediaCard(section);\n\t}\n\n\tdisplayMediaCard(section) {\n\t\tthis.medias.forEach(\n\t\t\t(\n\t\t\t\t/** @type {{ photographerId: any; image: string; video: string; title: any; likes: any; }} */ media\n\t\t\t) => {\n\t\t\t\tif (media.photographerId == this.id) {\n\t\t\t\t\tnew MediaCard(section, {\n\t\t\t\t\t\timgLink: "./img/photos/" + media.image,\n\t\t\t\t\t\tvideoLink: "img/videos/" + media.video,\n\t\t\t\t\t\timgTitle: media.title,\n\t\t\t\t\t\tlike: media.likes,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(media.video);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// const likes = document.querySelectorAll(".like");\n\t\t// console.log(likes);\n\t\t// likes.forEach((like) => {\n\t\t// \tlike.addEventListener("click", () => {\n\t\t// \t\tconsole.log("test");\n\t\t// \t\tmediaCard =\n\t\t// \t});\n\t\t// });\n\t}\n}\n\n;// CONCATENATED MODULE: ./src/app.js\n// import Header from "./components/header/header";\n// import PhotographerCard from "./components/photographer-card/photographer-card";\n// // import FilterLink from "./components/filterLink/filterLink";\n// // const { util } = require("webpack");\n\n// // import Widget from "./components/widget/widget";\n// // import FormModal from "./components/form-modal/form-modal";\n// // import BtContact from "./components/btContact/btContact";\n\n// import { fetchPhotographers } from "./services/dataManager";\n\n// // fetchPhotographers();\n// /**\n//  * Affichage de chaque description de photographe\n//  *\n//  * @return  {promise}      Affichage de chaque description de photographe\n//  */\n// async function displayPhotographersDescriptions() {\n// \tconst photographers = await fetchPhotographers();\n// \tphotographers.forEach((photographer) => {\n// \t\tnew PhotographerCard(document.querySelector("main"), {\n// \t\t\t...photographer,\n// \t\t\tarticleClassName: "photographer-card",\n// \t\t\tbtClassName: "photographer-card-link",\n// \t\t});\n// \t});\n// }\n\n// new Header(document.querySelector("header"));\n// displayPhotographersDescriptions();\n\n/* ******************************************************************************************************************************************************** */\n\n\n\n\n\n\n\n\n\nconst body = document.body;\n/**\n * Tableau contenant les tags Checked\n *\n * @var {array}\n */\nlet tagsChecked = [];\n/**\n * [id description]\n *\n * @var {[type]}\n */\nlet id;\n\n/* *************************************************************************************************************************************************************************************************************************************************************** */\n/**\n * Object contains functions utils\n *\n * @var {object}\n */\nconst utils = {\n\tgoToContentManage: function () {\n\t\tconst goToContent = document.querySelector(".goToContent");\n\t\tif (goToContent !== null) {\n\t\t\tif (window.scrollY > 20) {\n\t\t\t\tgoToContent.setAttribute("visible", "true");\n\t\t\t\tgoToContent.addEventListener("click", () => {\n\t\t\t\t\twindow.location.href = "#main";\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgoToContent.removeAttribute("visible");\n\t\t\t}\n\t\t}\n\t},\n\n\trazLobby: function () {\n\t\ttagsChecked = [];\n\t\tviews.lobby();\n\t},\n\n\ttagsManage: function () {\n\t\tconst tags = document.querySelectorAll(".tags-link");\n\t\ttags.forEach((tag) => {\n\t\t\ttag.addEventListener("click", () => {\n\t\t\t\tif (!tag.hasAttribute("isChecked")) {\n\t\t\t\t\ttag.setAttribute("isChecked", "true");\n\t\t\t\t\ttagsChecked.push(tag.innerHTML);\n\t\t\t\t} else {\n\t\t\t\t\ttag.removeAttribute("isChecked");\n\t\t\t\t\ttagsChecked.splice(tagsChecked.indexOf(tag.innerHTML), 1);\n\t\t\t\t}\n\t\t\t\tviews.lobby();\n\t\t\t\treturn tagsChecked;\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t * Au clic sur button active la view\n\t *\n\t * @param   {HTMLElement} element  button  button\n\t * @param   {object}  view   View à activer\n\t *\n\t * @return  {void}          Definie la view en fonction du clic sur button\n\t */\n\tactiveLink: function (button, view) {\n\t\tbutton.addEventListener("click", view);\n\t},\n\n\t/**\n\t * Affichage de la description du photographe dans views.photographer\n\t *\n\t * @param   {number}  id  id du photographe\n\t *\n\t * @return  {promise}      Affiche la description du photographe dans views.photographer en fonction de son id\n\t */\n\tdisplayPhotographersCardsBig: async function (photographers, id) {\n\t\tconst main = document.createElement("main");\n\t\tmain.id = "photographer-main";\n\t\tdocument.body.appendChild(main);\n\t\tphotographers.forEach((photographer) => {\n\t\t\tif (photographer.id == id) {\n\t\t\t\tnew PhotographerCardBig(main, {\n\t\t\t\t\t...photographer,\n\t\t\t\t\tarticleClassName: "photographer-card-big",\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Au clic sur un des buttons active la view\n\t *\n\t * @param   {NodeListOf}  buttons  Array of buttons\n\t * @param   {object}  view   View à activer\n\t *\n\t * @return  {void}            Definie la view en fonction du clic sur un des buttons\n\t */\n\tactiveManyLinks: function (buttons, view) {\n\t\tbuttons.forEach((button) => {\n\t\t\tbutton.addEventListener("click", view);\n\t\t});\n\t},\n\n\t/**\n\t * Recupération de l\'id du photographe lors du clic sur sa carte\n\t *\n\t * @param   {NodeListOf}  buttons  Cartes des photographes\n\t *\n\t * @return  {any}         Retourne l\' id du photographe dont la carte a été cliqué\n\t */\n\trecupLinkId: function (buttons) {\n\t\tbuttons.forEach((button) => {\n\t\t\tbutton.addEventListener("click", () => {\n\t\t\t\tid = button.id;\n\t\t\t\treturn id;\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Affichage de chaque carte de photographe\n\t *\n\t * @param  {string | string[]}  tagsChecked   Tags checked\n\t *\n\t * @return  {promise}      Affichage de chaque carte de photographe\n\t */\n\tdisplayPhotographersCards: async function (photographers, tagsChecked) {\n\t\tconst main = document.createElement("main");\n\t\tmain.id = "main";\n\t\tdocument.body.appendChild(main);\n\t\tphotographers.forEach((/** @type {{ tags: any[]; }} */ photographer) => {\n\t\t\tif (tagsChecked === undefined || tagsChecked.length === 0) {\n\t\t\t\tnew PhotographerCard(main, {\n\t\t\t\t\t...photographer,\n\t\t\t\t\tarticleClassName: "photographer-card",\n\t\t\t\t\tbtClassName: "photographer-card-link",\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst test = photographer.tags.some((tag) =>\n\t\t\t\t\ttagsChecked.includes("#" + tag)\n\t\t\t\t);\n\t\t\t\tif (test) {\n\t\t\t\t\tnew PhotographerCard(main, {\n\t\t\t\t\t\t...photographer,\n\t\t\t\t\t\tarticleClassName: "photographer-card",\n\t\t\t\t\t\tbtClassName: "photographer-card-link",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst buttons = document.querySelectorAll(".photographer-card-link");\n\t\tutils.recupLinkId(buttons);\n\t\tutils.activeManyLinks(buttons, views.photographer);\n\t},\n};\n/* *************************************************************************************************************************************************************************************************************************************************************** */\n/**\n * Object contains functions for views\n *\n * @var {object}\n */\nconst views = {\n\t/**\n\t * Gestion of view lobby\n\t *\n\t * @return  {promise}  Fonctionnalités et affichage de la vue lobby\n\t */\n\tlobby: async function () {\n\t\tconst photographers = await fetchPhotographers();\n\t\tnew Header(body, tagsChecked, "header");\n\t\tnew BtContact(body, {\n\t\t\tclassName: "goToContent",\n\t\t\ttype: "button",\n\t\t\ttext: "Passer au contenu",\n\t\t});\n\t\tawait utils.displayPhotographersCards(photographers, tagsChecked);\n\t\tutils.tagsManage();\n\t\tdocument.addEventListener("scroll", utils.goToContentManage);\n\t},\n\n\t/**\n\t * Gestion of view photographer\n\t *\n\t * @return  {promise}  Fonctionnalités et affichage de la vue photographer\n\t */\n\tphotographer: async function () {\n\t\ttagsChecked = [];\n\t\tconst photographers = await fetchPhotographers();\n\t\tconst medias = await fetchMedia();\n\t\t// console.log(medias);\n\t\tnew Header(body, tagsChecked, "header", "header-photographer");\n\t\tawait utils.displayPhotographersCardsBig(photographers, id);\n\t\tconst main = document.querySelector("main");\n\t\tnew Widget(main);\n\t\tnew MediaCardsSection(main, { medias: medias, id: id });\n\t\tutils.tagsManage();\n\t},\n\n\t/**\n\t * Gestion of view lightbox\n\t *\n\t * @return  {void}  Fonctionnalités et affichage de la vue lightbox\n\t */\n\tlightbox: function () {},\n\n\t/**\n\t * Gestion of view formModal\n\t *\n\t * @return  {void}  Fonctionnalités et affichage de la vue formModal\n\t */\n\tformModal: function () {},\n};\n\n// @ts-ignore\nwindow.goHome = utils.razLobby;\nviews.lobby();\n\n\n//# sourceURL=webpack://p6/./src/app.js_+_9_modules?')}},__webpack_exports__={};__webpack_modules__[390]()})();