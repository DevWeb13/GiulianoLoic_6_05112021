{"version":3,"sources":["photographer.js"],"names":["widget","document","getElementById","deactivateSelect","select","classList","contains","querySelector","add","remove","activeSelect","selectList","forEach","toggleOptList","toggle","highlightOption","option","querySelectorAll","other","updateValue","index","nativeWidget","previousElementSibling","value","optionList","setAttribute","selectedIndex","innerHTML","getIndex","console","log","window","addEventListener","tabIndex","e","length","keyCode"],"mappings":"AAAA,MAAAA,OAAAC,SAAAC,eAAA,UAWA,SAAAC,iBAAAC,GAEAA,EAAAC,UAAAC,SAAA,YAEAF,EAAAG,cAAA,YAEAF,UAAAG,IAAA,UAEAJ,EAAAC,UAAAI,OAAA,WAOA,SAAAC,aAAAN,EAAAO,GAEAP,EAAAC,UAAAC,SAAA,WAKAK,EAAAC,QAAAT,kBASA,SAAAU,cAAAT,GAEAA,EAAAG,cAAA,YAEAF,UAAAS,OAAA,UACAV,EAAAC,UAAAS,OAAA,UAQA,SAAAC,gBAAAX,EAAAY,GAEAZ,EAAAa,iBAAA,WAEAL,QAAA,SAAAM,GACAA,EAAAb,UAAAI,OAAA,eAGAO,EAAAX,UAAAG,IAAA,aAgDA,SAAAW,YAAAf,EAAAgB,GAGA,IAAAC,EAAAjB,EAAAkB,uBAEAC,EAAAnB,EAAAG,cAAA,UAEAiB,EAAApB,EAAAa,iBAAA,WAEAO,EAAAZ,QAAA,SAAAM,GACAA,EAAAO,aAAA,gBAAA,WAGAD,EAAAJ,GAAAK,aAAA,gBAAA,QAEAJ,EAAAK,cAAAN,EAEAG,EAAAI,UAAAH,EAAAJ,GAAAO,UAEAZ,gBAAAX,EAAAoB,EAAAJ,IAMA,SAAAQ,SAAAxB,GAKA,OADAA,EAAAkB,uBACAI,cA5IAG,QAAAC,IAAA9B,QAEA+B,OAAAC,iBAAA,OAAA,WACAhC,OAAAK,UAAAI,OAAA,aACAT,OAAAK,UAAAG,IAAA,YA8DAuB,OAAAC,iBAAA,OAAA,WACA,IAAArB,EAAAV,SAAAgB,iBAAA,WAEAN,EAAAC,QAAA,SAAAR,GAEAA,EAAAa,iBAAA,WAGAL,QAAA,SAAAI,GACAA,EAAAgB,iBAAA,YAAA,WAGAjB,gBAAAX,EAAAY,OAIAZ,EAAA4B,iBAAA,QAAA,WAIAnB,cAAAT,KAKAA,EAAA4B,iBAAA,QAAA,WAIAtB,aAAAN,EAAAO,KAGAP,EAAA4B,iBAAA,OAAA,WAIA7B,iBAAAC,SA0CA2B,OAAAC,iBAAA,OAAA,WACA/B,SAAAgB,iBAAA,WAEAL,QAAA,SAAAR,GACA,IAAAoB,EAAApB,EAAAa,iBAAA,WACAS,EAAAE,SAAAxB,GAEAA,EAAA6B,SAAA,EAEA7B,EAAAkB,uBAAAW,UAAA,EAEAd,YAAAf,EAAAsB,GAGAF,EAAAZ,QAAA,SAAAI,EAAAI,GACAJ,EAAAgB,iBAAA,QAAA,WACAb,YAAAf,EAAAgB,OAKAhB,EAAA4B,iBAAA,QAAA,SAAAE,GACA,IAAAC,EAAAX,EAAAW,OACAf,EAAAQ,SAAAxB,GAEA,KAAA8B,EAAAE,SAAAhB,EAAAe,EAAA,GACAf,IAGA,KAAAc,EAAAE,SAAA,EAAAhB,GACAA,IAGA,KAAAc,EAAAE,UACAhC,EAAAG,cAAA,YAEAF,UAAAS,OAAA,UACAV,EAAAC,UAAAS,OAAA,WAEAK,YAAAf,EAAAgB","file":"photographer.js","sourcesContent":["const widget = document.getElementById(\"widget\");\nconsole.log(widget);\n\nwindow.addEventListener(\"load\", function () {\n\twidget.classList.remove(\"no-widget\");\n\twidget.classList.add(\"widget\");\n});\n\n// Cette fonction est utilisée chaque fois que nous voulons désactiver un\n// widget personnalisé. Elle prend un paramètre\n// select : le nœud DOM avec la classe select à désactiver\nfunction deactivateSelect(select) {\n\t// Si le widget n'est pas actif, il n'y a rien à faire\n\tif (!select.classList.contains(\"active\")) return;\n\t// Nous devons obtenir la liste des options pour le widget personnalisé\n\tvar optList = select.querySelector(\".optList\");\n\t// Nous cachons la liste des options\n\toptList.classList.add(\"hidden\");\n\t// et nous désactivons le widget personnalisé lui-même\n\tselect.classList.remove(\"active\");\n}\n\n// Cette fonction sera utilisée chaque fois que l'utilisateur veut (des)activer le widget\n// Elle prend deux paramètres :\n// select : le nœud DOM de la classe `select` à activer\n// selectList : la liste de tous les nœuds DOM de la classe `select`\nfunction activeSelect(select, selectList) {\n\t// Si le widget est déjà actif il n'y a rien à faire\n\tif (select.classList.contains(\"active\")) return;\n\t// Nous devons désactiver tous les widgets personnalisés\n\t// comme la fonction deactivateSelect remplit toutes les fonctionnalités de la\n\t// fonction de rappel forEach, nous l'utilisons directement sans utiliser\n\t// une fonction anonyme intermédiaire.\n\tselectList.forEach(deactivateSelect);\n\t// Et nous activons l'état du widget donné\n\t// select.classList.add(\"active\");\n}\n\n// Cette fonction sera utilisée chaque fois que l'utilisateur veut enrouler/dérouler la\n// liste des options\n// Elle prend un paramètre :\n// select : le nœud DOM de la liste à basculer\nfunction toggleOptList(select) {\n\t// La liste est prise à partir du widget\n\tvar optList = select.querySelector(\".optList\");\n\t// Nous changeons la classe de la liste pour l'enrouler/dérouler\n\toptList.classList.toggle(\"hidden\");\n\tselect.classList.toggle(\"active\");\n}\n\n// Cett fonction sera utilisée chaque fois qu'il faut mettre en surbrillance\n// une option.  Elle prend deux paramètres :\n// select : le nœud DOM de la classe `select`\n//          contenant l'option à mettre en surbrillance\n// option : le nœud DOM de la classe `option` à mettre en surbrillance\nfunction highlightOption(select, option) {\n\t// Obtenir la liste de toutes les options disponibles pour l'élémént sélectionné\n\tvar optionList = select.querySelectorAll(\".option\");\n\t// Supprimer la surbrillance pour toutes les options\n\toptionList.forEach(function (other) {\n\t\tother.classList.remove(\"highlight\");\n\t});\n\t// Mettre en surbrillance l'option correcte\n\toption.classList.add(\"highlight\");\n}\n\n// Nous lions le widget aux événements dès le chargement du document\nwindow.addEventListener(\"load\", function () {\n\tvar selectList = document.querySelectorAll(\".select\");\n\t// Chaque widget personnalisé doit être initialisé\n\tselectList.forEach(function (select) {\n\t\t// de même que tous les éléments `option`\n\t\tvar optionList = select.querySelectorAll(\".option\");\n\t\t// Chaque fois que l'utilisateur passe le pointeur de souris\n\t\t// sur une option, nous mettons en surbrillance la dite option\n\t\toptionList.forEach(function (option) {\n\t\t\toption.addEventListener(\"mouseover\", function () {\n\t\t\t\t// Note : les variables `select` et `option` sont des \"closures\"\n\t\t\t\t// disponibles dans la portée de notre appel de fonction.\n\t\t\t\thighlightOption(select, option);\n\t\t\t});\n\t\t});\n\t\t// Chaque fois que l'utilisateur clique sur un élément personnalisé\n\t\tselect.addEventListener(\"click\", function () {\n\t\t\t// Note : la variable `select` est une \"closure\"\n\t\t\t// available dans la portée de notre appel de fonction.\n\t\t\t// Nous basculons la visibilité de la liste des options\n\t\t\ttoggleOptList(select);\n\t\t});\n\t\t// Dans le cas où le widget obtient le focus\n\t\t// Le widget obtient le focus chaque fois que l'utilisateur clique dessus\n\t\t// ou presse la touche Tab pour avoir accès au widget\n\t\tselect.addEventListener(\"focus\", function () {\n\t\t\t// Note : les variable `select` et `selectList` sont des \"closures\"\n\t\t\t// disponibles dans la portée de notre appel de fonction.\n\t\t\t// Nous activons le widget\n\t\t\tactiveSelect(select, selectList);\n\t\t});\n\t\t// Dans le cas où le widget perd le focus\n\t\tselect.addEventListener(\"blur\", function () {\n\t\t\t// Note : la variable `select` est une \"closure\"\n\t\t\t// disponible dans la portée de notre appel de fonction.\n\t\t\t// Nous désactivons le widget\n\t\t\tdeactivateSelect(select);\n\t\t});\n\t});\n});\n// Cette fonction met à jour la valeur affichée et la synchronise avec celle\n// du widget natif. Elle prend deux paramètres :\n// select : le nœud DOM de la classe `select` contenant la valuer à mettre à jour\n// index  : l'index de la valeur choisie\nfunction updateValue(select, index) {\n\t// Nous devons obtenir le widget natif correspondant au widget personnalisé\n\t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n\tvar nativeWidget = select.previousElementSibling;\n\t// Nou devons aussi obtenir la valeur de remplacement du widget personnalisé\n\tvar value = select.querySelector(\".value\");\n\t// Et nous avons besoin de toute la liste des options\n\tvar optionList = select.querySelectorAll(\".option\");\n\t// Nous nous assurons qu'aucune option n'est sélectionnée\n\toptionList.forEach(function (other) {\n\t\tother.setAttribute(\"aria-selected\", \"false\");\n\t});\n\t// Nous nous assurons que l'option choisie est sélectionnée\n\toptionList[index].setAttribute(\"aria-selected\", \"true\");\n\t// Nous définissons l'index choisi à l'index du choix\n\tnativeWidget.selectedIndex = index;\n\t// Nous mettons à jour la valeur de remplacement en accord\n\tvalue.innerHTML = optionList[index].innerHTML;\n\t// Et nous mettons en surbrillance l'option correspondante du widget personnalisé\n\thighlightOption(select, optionList[index]);\n}\n\n// Cette fonction renvoie l'index courant dans le widget natif\n// Elle prend un paramètre :\n// select : le nœud DOM avec la classe `select` relative au widget natif\nfunction getIndex(select) {\n\t// Nous avons besoin d'avoir accès au widget natif pour le widget personnalisé\n\t// Dans notre exemple, le widget natif est un parent du widget personnalisé\n\n\tvar nativeWidget = select.previousElementSibling;\n\treturn nativeWidget.selectedIndex;\n}\n\n// Nous lions le widget aux événements dès le chargement du document\nwindow.addEventListener(\"load\", function () {\n\tvar selectList = document.querySelectorAll(\".select\");\n\t// Chaque widget personnalisé doit être initialisé\n\tselectList.forEach(function (select) {\n\t\tvar optionList = select.querySelectorAll(\".option\"),\n\t\t\tselectedIndex = getIndex(select);\n\t\t// Nous rendons le widget personnalisé capable d'avoir le focus\n\t\tselect.tabIndex = 0;\n\t\t// Nous faisons en sorte que le widget natif ne puisse plus avoir le focus\n\t\tselect.previousElementSibling.tabIndex = -1;\n\t\t// Nous nous assurons que la valeur sélectionnée par défaut est bien affichée\n\t\tupdateValue(select, selectedIndex);\n\t\t// Chaque fois que l'utilisateur clique sur une option, nous mettons à\n\t\t// jour la valeur en accord\n\t\toptionList.forEach(function (option, index) {\n\t\t\toption.addEventListener(\"click\", function () {\n\t\t\t\tupdateValue(select, index);\n\t\t\t});\n\t\t});\n\t\t// Chaque fois que l'utilisateur utilise le clavier sur un widget\n\t\t// avec focus, les valeurs sont mises à jour en accord\n\t\tselect.addEventListener(\"keyup\", function (e) {\n\t\t\tvar length = optionList.length,\n\t\t\t\tindex = getIndex(select);\n\t\t\t// Quand l'utilisateur presse ⇓, nous allons à l'option suivante\n\t\t\tif (e.keyCode === 40 && index < length - 1) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t// Quand l'utilisateur presse ⇑, nous sautons à l'option suivante\n\t\t\tif (e.keyCode === 38 && index > 0) {\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\t// Quand l'utilisateur presse enter, nous mettons à jour la valeur en accord\n\t\t\tif (e.keyCode === 13) {\n\t\t\t\tvar optList = select.querySelector(\".optList\");\n\t\t\t\t// Nous changeons la classe de la liste pour l'enrouler/dérouler\n\t\t\t\toptList.classList.toggle(\"hidden\");\n\t\t\t\tselect.classList.toggle(\"active\");\n\t\t\t}\n\t\t\tupdateValue(select, index);\n\t\t});\n\t});\n});\n"]}